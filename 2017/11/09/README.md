# 139：简单的线程死锁

在编写多线程程序时，必须注意资源的使用问题。如果两个线程（多个线程情况类似）分别拥有不同的资源，而同时又需要对方释放资源才能继续运行时，就会发生死锁。

> 当 d1 的 run() 方法运行时，首先获得 o1 对象的内置锁。在其休眠的 1 秒钟内，d2 的 run() 方法开始运行，它获得了 o2 对象的内置锁并进入休眠状态。而当 d1 的 run() 方法需要获得 o2 的内置锁时，该锁已经被占用，因此进入了死锁状态。

运行结果：

<img src="http://image.renkaigis.com/keepcoding/2017110901.png">

> 注意：红色区域表示程序并未运行结束，因为发生了死锁。

# 140：解决线程的死锁问题

// 对于 4 个同步块，去掉任何一个就可以解决死锁问题。

当具备一下 4 个条件时，就会产生死锁：

- 资源互斥(资源只能供一个线程使用)

- 请求保持（拥有资源的线程在请求新的资源又不释放占有的资源）

- 不能剥夺（已经获得的资源在使用完成前不能剥夺）

- 循环等待（各个线程对资源的需求构成一个循环）

运行结果：

```java
Thread-0:flag = true
Thread-1:flag = false
Thread-0进入同步块 o1 准备进入 o2
Thread-0已经进入同步块 o2
Thread-1进入同步块 o2 准备进入 o1
Thread-1已经进入同步块 o1
```

<img src="http://image.renkaigis.com/keepcoding/2017110902.png">

